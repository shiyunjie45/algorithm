package com.sky.algorithmleetcode;

/*
传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。 传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装
载包裹。我们装载的重量不会超过船的最大运载重量。 返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。   示例 1： 输入：weights = [1
,2,3,4,5,6,7,8,9,10], D = 5 输出：15 解释： 船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示： 第 1 天：1, 2
, 3, 4, 5 第 2 天：6, 7 第 3 天：8 第 4 天：9 第 5 天：10 请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶
并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。  示例 2： 输入：weights = [3,2,2
,4,1,4], D = 3 输出：6 解释： 船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示： 第 1 天：3, 2 第 2 天：2, 4 第 3
 天：1, 4  示例 3： 输入：weights = [1,2,3,1,1], D = 4 输出：3 解释： 第 1 天：1 第 2 天：2 第 3 天：3 
第 4 天：1, 1    提示：  	1 	1
*/

 class L1011Solution {
    public int shipWithinDays(int[] weights, int D) {
        int left = 0, right = 0;
        for (int w : weights) {
            left = Math.max(left, w); // 确定左边界为最大的货物重量
            right += w; // 右边界为所有货物总重量
        }
        while (left < right) {
            int mid = (left + right) / 2; // 二分查找，确定运载能力的中点
            int need = 1, cur = 0;
            for (int w : weights) {
                if (cur + w > mid) { // 如果超过了中点，需要开新的一天，需要加1
                    need++;
                    cur = 0; // 当前的运载量清零
                }
                cur += w;
            }
            if (need <= D) { // 如果需要的天数小于等于规定的天数，就减小运载能力，使得能在规定时间内完成运输
                right = mid;
            } else { // 如果需要的天数大于规定的天数，就增大运载能力，使得能在规定时间内完成运输
                left = mid + 1;
            }
        }
        return left;
    }
} 