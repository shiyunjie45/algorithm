package com.sky.algorithmleetcode;

/*
你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：  	每首歌至少播放
一次。 	一首歌只有在其他 K 首歌播放完之后才能再次播放。  返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。  
 示例 1： 输入：N = 3, L = 3, K = 1 输出：6 解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]
，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].  示例 2： 输入：N = 2, L = 3, K = 0 输出：6 解释：有 6 种可能的播放
列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]  示例 3： 输入：N = 2, 
L = 3, K = 1 输出：2 解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]    提示：  	0
*/

题目描述

对于一首歌曲来说，必须要在 k 首其他不同的歌曲之后才能再次播放。要构造一个长度为 L 的播放列表，使得其中的每一首歌曲至少被播放一次，并且每首歌曲都能在其他 K 首不同的歌曲播放之后再次被播放。求有多少种不同的播放列表。

算法思想

这个题目非常巧妙，解法比较难想到。首先，通过归纳法证明，如果在列表的末尾加入一首歌曲，那么其播放次数可能为 1, 2, 3, ..., k + 1 次。当播放次数为 i（i <= k + 1）次时，末尾歌曲之前剩下的歌曲数量为 n - 1，剩下的可用次数总和为 i - 1。这个问题可以用动态规划的思想解决。

dp[i][j] 表示剩余 i 首歌曲，可以再次播放的总次数为 j 的方案总数。

状态转移方程为：

dp[i][j] = dp[i-1][j-1] * (n - i + 1) + dp[i][j-1] * max(0, i-k-1)

解释：

dp[i-1][j-1] * (n - i + 1) 表示将当前末尾歌曲加入播放列表之前，首先需要从前面选取 i - 1 首其他歌曲进行播放。因此方案数为前 i - 1 首歌曲的方案数 dp[i-1][j-1] 乘以当前可以取的剩余歌曲数量 (n - i + 1)。

dp[i][j-1] * max(0, i-k-1) 表示前面的 i - 1 首歌曲总次数为 j - 1 时，再次播放当前末尾歌曲的方案数。由于当前末尾歌曲最早需要等前面播放过 k 首其他歌曲之后才能再次播放，所以需要判断 i - k - 1 是否大于 0。

边界情况：当只剩下 1 首歌曲时，只有 j = 1 的方案数为 1。

最终答案为 dp[l][k+1]。

Java代码 