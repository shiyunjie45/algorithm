package com.sky.algorithmleetcode;

/*
在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中，除了在 mines 中给出的单元为 0，其他每个单元都是 1。网格中包含 1 的
最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。 一个 k" 阶由 1 组成的“轴对称”加号标志具有中心网格  grid[x]
[y] = 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。下面给出 k" 阶“轴对称”加号标志的示例。注意，只有加号标志的所
有网格要求为 1，别的网格可能为 0 也可能为 1。   k 阶轴对称加号标志示例:  阶 1: 000 010 000 阶 2: 00000 00100 01
110 00100 00000 阶 3: 0000000 0001000 0001000 0111110 0001000 0001000 0000000    
示例 1：  输入: N = 5, mines = [[4, 2]] 输出: 2 解释: 11111 11111 11111 11111 11011 在上面的网
格中，最大加号标志的阶只能是2。一个标志已在图中标出。    示例 2：  输入: N = 2, mines = [] 输出: 1 解释: 11 11 没有 2
 阶加号标志，有 1 阶加号标志。    示例 3：  输入: N = 1, mines = [[0, 0]] 输出: 0 解释: 0 没有加号标志，返回 0 
。    提示：  	整数N 的范围： [1, 500]. 	mines 的最大长度为 5000. 	mines[i] 是长度为2的由2个 [0, N-1] 中
的数组成. 	(另外,使用 C, C++, 或者 C# 编程将以稍小的时间限制进行​​判断.)
*/

 class L764Solution {
    public int orderOfLargestPlusSign(int N, int[][] mines) {
        //通过二维数组记录网格中1的个数
        int[][] grid = new int[N][N];
        //初始化所有位置都为N
        for(int i=0; i<N; i++){
            Arrays.fill(grid[i], N);
        }
        //挖去矿山，即将矿山位置grid中的值变为0，即1的个数变为0
        for(int[] mine: mines){
            grid[mine[0]][mine[1]] = 0;
        }
        //逐一检查每个位置，计算以此位置为中心的最大轴对称加号标志的阶数
        for(int i=0; i<N; i++){
            for(int j=0, k=N-1, l=0, r=0, u=0, d=0; j<N; j++, k--){
                //从左往右扫描，更新左边的1的个数
                grid[i][j] = Math.min(grid[i][j], l = (grid[i][j] == 0? 0: l+1));
                //从右往左扫描，更新右边的1的个数
                grid[i][k] = Math.min(grid[i][k], r = (grid[i][k] == 0? 0: r+1));
                //从上往下扫描，更新上面的1的个数
                grid[j][i] = Math.min(grid[j][i], u = (grid[j][i] == 0? 0: u+1));
                //从下往上扫描，更新下面的1的个数
                grid[k][i] = Math.min(grid[k][i], d = (grid[k][i] == 0? 0: d+1));
            }
        }
        //找到最大的加号标志的阶数
        int maxOrder = 0;
        for(int i=0; i<N; i++){
            for(int j=0; j<N; j++){
                maxOrder = Math.max(maxOrder, grid[i][j]);
            }
        }
        return maxOrder;
    }
} 