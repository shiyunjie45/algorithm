package com.sky.algorithmleetcode;

/*
给定一个字符串 S，计算 S 的不同非空子序列的个数。 因为结果可能很大，所以返回答案模 10^9 + 7.   示例 1： 输入："abc" 输出：7 解释：
7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。  示例 2： 输入："aba" 输出：6 解释：
6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。  示例 3： 输入："aaa" 输出：3 解释：3 个不同的
子序列分别是 "a", "aa" 以及 "aaa"。      提示：  	S 只包含小写字母。 	1
*/

. 原问题可以转化为：对于每个字符，它可以出现在若干不同的子序列中，我们求所有字符可以出现的子序列数量之和。

2. 假设 S 中共有 n 个不同的字符，则所有字符可以出现的子序列数量之和等于这 n 个字符生成的子序列数量之和，即 2^n-1。这里注意要减去空字符串。

3. 遍历字符串 S，统计每个字符可以出现在若干不同子序列中的数量，最终相加即可。

4. 由于结果需要对 10^9+7 取模，为了避免乘法产生的溢出问题，可以使用取模运算的分配律：(a×b) mod p=(a mod p)×(b mod p) mod p。 